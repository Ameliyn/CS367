---- ls -> list files
---- cd -> change directory
---- *command* & -> multithread (allow for use of console while in emacs)
---- ctrl-c -> close what working on
---- sftp *target@computername* -> "Secure file transfer protocol"
---- get *filename* -> take file from that computer and copy it to your computer
---- filename cheat: *partofFile*.pdf -> asterisks are wildcards and it gets any file that
     includes "partofFile" and ends in .pdf
---- cc -> call c compiler
---- gcc -o *name* *fileName* -> set a.out to be *name*
---- cc -lm -lX11 ->  "-lm" => link to math  "-lX11" => link to linux graphical library.
---- gcc -o *CompiledFileName* *FiletoCompile.c* -lm -lX11 -> use all stuff before and make
     it work for graphical things
---- gcc -O (capital O, makes the compiler optimize the code)
---- fg creates a whole bunch of files that are different steps of the compiler.
----"|" takes the output of the previous command and pipes it through another command
----"man" brings us the manual for a command
----"tar xfz *filename*.tgz" untar file (similar to a zip file, but different?)


C programming shit:
----"#define" makes constant GLOBAL variables for the program
----"#include" includes something, libraries are in <> and files are just names
----C passes everything EXCEPT ARRAYS by value (as copies)
    --can use pointers to pass things to pass actual things
      (arrays are always pointers so that makes sense)
----Strings: arrays of characters ended by "\0"
----"->" operator (instead of "class.method" (java) we use "class->method")
    --but we can still us ".variable" for public variables on non-pointers
----1 byte = 8 bits = 256 possible numbers
----Data types:
    --char => 1 byte
    --int => 4 bytes
    --long => 8 bytes
    --float => 4 bytes
    --double => 8 bytes
    --long double => 10 bytes
----Pointers:
  --char c; //declares char c
  --c = 65; //initializes char c to 65 ('a')
  --char *p; //declares pointer p to be pointer of type char
  --p = &c;  //p gets memory location of c
  --p = 0; //sets p to be the memory location 0
  --printf("%c\n", *p); //*p gets the value of the pointer (goes back and forth)
  --char **argv
    --argv points to pointers (an array of pointers to arrays)
    --printf line returns "Segmentation fault (core dumped)" because the OS got mad.
    --char *p is a pointer of type char in memory (declared by "*")
      --standardly takes up 8 bytes (64bit computing)
    --generate pointer of existing thing "&c"
    --can manufacture addresses
    --*p is the same as p[0] in this previous code (dereferencing a pointer gives you the value)
----Structs:
  --"struct cplx {double re; double im;}"
  --*in main* "struct cplx c1 = {1.0, 0.0}"
    --an inanimate object to store multiple variables (two doubles in this case)
    --can create with simple curly braces
----Bitwise operations:
    --FUTURE SKYE FIGURE THIS OUT
----Command line arguments
    --main can have arguments (as expected)
      --"int main(int argc, char **argv){}"
      --"argc" = integer, how many words on command line
      --"argv" = array of pointers to char arrays (array of strings)


CS 367 Graphics office hours: MWF 10:20-11:20 in Bodine 301


Functions and Parameter Passing in C: (2 September, 2021 Jeff)
--Functions pass copies of values inherently (as expected, methods cannot directly
  edit main program variables.
  --CAREFUL: Arrays break this. AND ONLY ARRAYS (because methods send memory location of
    initial part of array. In methods, always make copies of the arrays if you don't
    want to change them.
--Arrays don't have a .length, that is why G_polygon needs the number of items.


A look behind the curtain and pointers: (3 September, 2021 Alain)
--fg shows us the steps the compiler goes throug, then call "cc hello.c"
  --First the cpp makes "hello.i" (DONT KNOW WHAT THIS IS LMAO GOOD LUCK)
  --Then ccl (c compiler) creates "hello.s" in assembly language. (mostly assembly instructions)
    --First column are largely labels ("main:")
    --first column contains psuedoinstructions (".anything")
  --Then as makes "hello.o" which is a binary file (hard to show with less/emacs/regular editors
    --some code allows us to read it like assembly "objdump -d hello.o | less"
      --objdump is a tool in linux that lets us look at binary files (converts it to stuff we can read)
      --"-d" tells the program to find the instructions, and largely ignore the raw data
      --"|" takes the output of the previous command and pipes it through another command
      --objdump will show largely the same thing as "hello.s"
  --Then "ld" makes "hello" which is the executable file
    --"ld" includes the libraries? tf? I think they are inherent libraries that allow c to work
      --by default it includes the libraries (so i was right a line above this)
        (such as IO, or string, etc)
      --"-lm" tells the compiler to include math AS WELL AS "#include <math.h>"
        (we do it twice because C)
      
.xy file structure:
--Number of Verticies (int)
--double coordinates of verticies (double x double y)
--Number of polygons (int)
--Each polygon ("number of verticies" "verticy number" "verticy number") (all ints)
--Each polygon's color ("double r" "double g" "double b")



CS367 Lab Notes:

--Count triangles twice, count non-triangles once
  --triangles are poitive slope then negative slope or negative slope then positive slope
    when vertex is in between xouters
    --perhaps worry about if a line is drawn twice on a polygon or not (two horizontal overlapping lines with
      vertex in the middle)
