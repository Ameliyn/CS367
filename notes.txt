Linux Shit:
---- ls -> list files
---- cd -> change directory
---- *command* & -> multithread (allow for use of console while in emacs)
---- ctrl-c -> close what working on
---- sftp *target@computername* -> "Secure file transfer protocol"
---- get *filename* -> take file from that computer and copy it to your computer
---- filename cheat: *partofFile*.pdf -> asterisks are wildcards and it gets any file that
     includes "partofFile" and ends in .pdf
---- cc -> call c compiler
---- gcc -o *name* *fileName* -> set a.out to be *name*
---- cc -lm -lX11 ->  "-lm" => link to math  "-lX11" => link to linux graphical library.
---- gcc -o *CompiledFileName* *FiletoCompile.c* -lm -lX11 -> use all stuff before and make
     it work for graphical things
---- gcc -O (capital O, makes the compiler optimize the code)
---- fg creates a whole bunch of files that are different steps of the compiler.
----"|" takes the output of the previous command and pipes it through another command
----"man" brings us the manual for a command
----"tar xfz *filename*.tgz" untar file (similar to a zip file, but different?)
----"od -t x1 mstore.o | less" takes binary file and makes it 'readable' in hex
    od = object dump (a way to inspect and look at object files
----"objdump -d mstore.o" inspect and deconstruct binary file (a bit)
    53 = push | 48 89 = mov


C programming shit:
----Four stages: Preprocessing, C-Compiler creates an assembly, Assembler encodes, Linker
    CC -c takes source files and goes through first three steps (preprocess, compiles, assembles)
    linker links .o files plus libraries and makes executable file (cc can do this and does it smartly)
----"#define" makes constant GLOBAL variables for the program
----"#include" includes something, libraries are in <> and files are just names
----C passes everything EXCEPT ARRAYS by value (as copies)
    --can use pointers to pass things to pass actual things
      (arrays are always pointers so that makes sense)
----Strings: arrays of characters ended by "\0"
----"->" operator (instead of "class.method" (java) we use "class->method")
    --but we can still us ".variable" for public variables on non-pointers
----1 byte = 8 bits = 256 possible numbers
----Data types:
    --char => 1 byte
    --int => 4 bytes
    --long => 8 bytes
    --float => 4 bytes
    --double => 8 bytes
    --long double => 10 bytes
----Pointers:
  --char c; //declares char c
  --c = 65; //initializes char c to 65 ('a')
  --char *p; //declares pointer p to be pointer of type char
  --p = &c;  //p gets memory location of c
  --p = 0; //sets p to be the memory location 0
  --printf("%c\n", *p); //*p gets the value of the pointer (goes back and forth)
  --char **argv
    --argv points to pointers (an array of pointers to arrays)
    --printf line returns "Segmentation fault (core dumped)" because the OS got mad.
    --char *p is a pointer of type char in memory (declared by "*")
      --standardly takes up 8 bytes (64bit computing)
    --generate pointer of existing thing "&c"
    --can manufacture addresses
    --*p is the same as p[0] in this previous code (dereferencing a pointer gives you the value)
----Structs:
  --"struct cplx {double re; double im;}"
  --*in main* "struct cplx c1 = {1.0, 0.0}"
    --an inanimate object to store multiple variables (two doubles in this case)
    --can create with simple curly braces
----Bitwise operations:
    --FUTURE SKYE FIGURE THIS OUT
----Command line arguments
    --main can have arguments (as expected)
      --"int main(int argc, char **argv){}"
      --"argc" = integer, how many words on command line
      --"argv" = array of pointers to char arrays (array of strings)
----C booleans (0 is false, anything else is true)


CS 367 Graphics office hours: MWF 10:20-11:20 in Bodine 301
Alain office hours Bodine 302A


Functions and Parameter Passing in C: (2 September, 2021 Jeff)
--Functions pass copies of values inherently (as expected, methods cannot directly
  edit main program variables.
  --CAREFUL: Arrays break this. AND ONLY ARRAYS (because methods send memory location of
    initial part of array. In methods, always make copies of the arrays if you don't
    want to change them.
--Arrays don't have a .length, that is why G_polygon needs the number of items.


A look behind the curtain and pointers: (3 September, 2021 Alain)
--fg shows us the steps the compiler goes throug, then call "cc hello.c"
  --First the cpp makes "hello.i" (DONT KNOW WHAT THIS IS LMAO GOOD LUCK)
  --Then ccl (c compiler) creates "hello.s" in assembly language. (mostly assembly instructions)
    --First column are largely labels ("main:")
    --first column contains psuedoinstructions (".anything")
  --Then as makes "hello.o" which is a binary file (hard to show with less/emacs/regular editors
    --some code allows us to read it like assembly "objdump -d hello.o | less"
      --objdump is a tool in linux that lets us look at binary files (converts it to stuff we can read)
      --"-d" tells the program to find the instructions, and largely ignore the raw data
      --"|" takes the output of the previous command and pipes it through another command
      --objdump will show largely the same thing as "hello.s"
  --Then "ld" makes "hello" which is the executable file
    --"ld" includes the libraries? tf? I think they are inherent libraries that allow c to work
      --by default it includes the libraries (so i was right a line above this)
        (such as IO, or string, etc)
      --"-lm" tells the compiler to include math AS WELL AS "#include <math.h>"
        (we do it twice because C)
      
.xy file structure:
--Number of Verticies (int)
--double coordinates of verticies (double x double y)
--Number of polygons (int)
--Each polygon ("number of verticies" "verticy number" "verticy number") (all ints)
--Each polygon's color ("double r" "double g" "double b")



CS367 poly_perimetersS Lab:

--Count triangles twice, count non-triangles once
  --triangles are poitive slope then negative slope or negative slope then positive slope
    when vertex is in between xouters
    --perhaps worry about if a line is drawn twice on a polygon or not (two horizontal overlapping
      lines with vertex in the middle)



Bitwise and Signed/Unsigned shit:
--When evaluating, if you have one unsigned and one signed, they are evaluated as unsigned
--signed -1 = 1111 1111 1111 1111	(255U = -1)
         -2 = 1111 1111 1111 1110	(You subtract 1 from 255U to get -2)
	 -3 = 1111 1111 1111 1101  (You subtract 2 from 255U to get -3)
	 -4 = 1111 1111 1111 1100	(...)
--1 << 1  (Shift by one position)
  0001 << 1 = 0010 (multiply by magnitude of 2)
  0X0012 << 1 = 0X0024
  v << k ≡ v × 2^k
--1 >> 1 (Shift right by one position)
  0001 >> 1 = 0000 (shift bits)
  1111 1111 (-1)>> 1 == 1111 1111 (-1)
  1111 1110 (-2)>> 1 == 1111 1111 (-1)
  1111 1100 (-4)>> 2 == 1111 1111 (-1)
  0X0012 >> 1 = 0X0005
  v >> k = floor(v/2^k)
  Fills in all positions vacated with the most significant bit (for signed values) (arithmetic shift)
  Fills in all positions vacated with zeroes (for unsigned values) (logical shift)
  --Example:
    char c = -4;
    c >> 2 == -1; //true (any vacated bit positions have been backfilled with most significant bit)
    unsigned char cc = (unsigned char) -4; cc == 1111 1100 (252 unsigned (-4 signed))
    cc >> 2 == 63 //true (any vacated bit positions have been backfilled with zeroes)
--& operator
  1111 1011 & 1011 0011 == 1011 0011
--| operator
  1111 1011 | 1011 0011 == 1111 1011
--~ operator
  ~1101 1111 == 0010 0000
--^ operator (XOR operator) (XOR yourself sets register to 0)
  1111 1101 ^ 1001 1001 == 0110 0100
--! operator
  0 == 1
  anything else == 0


MakeFile:
  CC=cc                     ("Symbol=something" : essentially definitions)
  EXEC=bitfun
  OBJS=driver.o bitlib.o
  OPTS=-std=c99 -Wall
  SOURCES=*.c

  all: $(EXEC)					 (automatically takes first recipe as target)
  
  $(EXEC): $(OBJS)                               (Dependencies "EXEC(target) depends on OBJS")
  	   $(CC) $(OPTS) $(OBJS) -o ($EXEC)      (Actual steps based on dependancies to create target)

  .c.o:	   	 	 	    		 (any file that has .c produces a .o through the following
	$(CC) $(OPTS) -c *.c			  line)

  clean:					 (here is what you do to undo actions)
        rm -f *.o $(EXEC) a.out


DeMorgan's Law (look up)
  

Floats in bits:

--What does 1011.101 represent?
  11.625 (11.5/8)
  (first four bits normal, next four 3 bits are 1/2 1/4 1/8)

--More generally our representation is b(subj) ... b(sub2) b(sub1) b(sub0) . b(sub-1) b(sub-2) ... b(sub-k)
  Result is sum from -k to j of b(subi)*2^i

  5 3/4 (5.75) to binary == 101.11
  2 7/8 (2.875) to binary == 10.111    (NOTICE: after the decimal point is the numerator in
  1 7/16 (1.4375) to binary == 1.0111    binary with leading zeroes if numerator is under 1/2)

--limitations to this form:
  --Cannot encode really small numbers or really big numbers

IEEE floating point form:
--(-1)^s x M x 2^E
  sign s = sign bit (pos or neg)
  significand M = fractional binary number (always begins with 1)
  exponent E = weights a value a power of 2
  E = x - 127 => E + 127 = x

--Examples:
  +1 (binary 1) = (-1)^0 + 1.0 + 2^0 == 0  01111111  00000000000000000000000
  +23 (binary 10111) = (-1)^0 + 1.0111 * 2^4 = 0 10000011 01110000000000000000000

--d.m * 2^p (d must be 1, so it doesn't need to be stored)

--float (32-bit/4 byte)
  0    00000000        00000000000000000000000
  31  30     23       22                     0
  s   8 bit exponent       23 bit fraction

--Normalized Values:

  E = exp-BIAS
  BIAS = 2^7-1 = 127
  M = 1 + f
  f = 0.frac(sub22)...frac(sub1)frac(sub0)
      (count from the right and put over 256) (or left and put to -1 power)

--Denormalized Values: exp = 0

  E = 1-BIAS
  BIAS = 2^7-1 = 127
  M = f
  f = 0.frac(sub22)...frac(sub1)frac(sub0)
      (count from the right and put over 256) (or left and put to -1 power)

--Special Values: exp = 255

  If frac == 0, value is +infinity if s = 0 and -infinity if s = 1
  If frac != 0, value is NaN (not a number)

--Multiply floats
  multiply the mantissas, and sum the exponents (and add the signs)

  (-1)^s1 * M1 * 2^E1
  (-1)^s2 * M2 * 2^E2
  ===================
  (-1)^(s1^s2) * (M1 * M2) * 2^(E1+E2)
         XOR    If (M1*M2) > 2, add 1 to E1+E2


Memory and Storage:
--BigEndian (most significant bit first)
--LittleEndian (least significant bit first) (intel architecture is this)
--90-99% of the time the endian that your computer uses does NOT MATTER TO US


Instructions Architecture and Specifications:
--Processor State:
  --Program Counter (PC | %rip)
  --Register File (16 64 bit)
  --Condition code
    Z (branch)
    S (set to 1 when result is negative)
    C (carry) (signed)
    O (overflow) (unsigned)
  --instruction registers
    |-------------(64bit)------------------|
    	        |---------(32bits)---------|
	                  |----(16 bits)---|
    (64bit)     (32 bit)  (16 bits)  (8 bit)
      %rax        %eax       %ax       %al    (return value)
      %rbx        %ebx	     %bl       %bl
      %rcx        %ecx	     %cx       %cl     
      %rdx        %edx	     %dx       %dl
      %rsi        %esi	     %si       %sil
      %rdi        %edi	     %di       %dil   (first argument)
      %rvp        %evp	     %vp       %bpl
      %rsp        %esp	     %sp       %spl
      %r8	  %r8d	     %r8w      %r8b	   
      %r9	  %r9d	     %r9w      %r9b
      ...
      %r15	  %r15d      %r15w     %r15b

    quad word(q) doubleWord(d(l)) word(w) byte (b)

--The stack pointer (%rsp)

--Format of instructions
  operation source2 source1/destination (op src2 src1/dest)
  src1 = src1 op src2
  
--Operand specifications that live inside instructions encoding

  IMMEDIATE
  REGISTER
  MEMORY

--intel architecture
  Instructions can be between 1 and 15byte length

Assembly operand specifiers:
"%rdi" register location
"(%rdi)" value at register rdi
"$0xf00d" immediate literal value
"$20(%rdi)" value at literal offset of memory (M[$20+%rdi])
"(%rdi,%rsi)" value at register offset of memory (M[%rdi + %rsi])
"$20(%rdi,%rsi)" value at register and immediate offset of memory (M[$20 + %rdi + %rsi])
"(,%rdi,s)" value at register scaled (M[%rdi * s])
"$20(,%rdi,s)" value at register scaled plus immediate(M[$20 + %rdi * s])
"(%rsi,%rdi,s)" value at register scaled plus register (M[%rsi + %rdi * s])
"$20(%rsi,%rdi,s)" value at register scaled plus register and immediate(M[$20 + %rsi + %rdi * s])

The Stack(tm):
"last in first out" paridigm
Largely handles function calls
"pushq S" (move the stack pointer to an empty spot and fill with S)
  R[%rsp] <- R[%rsp] - 8
  M[R[%rsp]] <- S
"popq D" (Fill D with current latest stack pointer and move stack pointer back one slot (pop it))
  D <- M[R[%rsp]]
  R[%rsp] <- R[%rsp] + 8


Assembly Code Specifications:
Pointers in C are memory addresses
--Derferencing a pointer
  Copy pointer to register
  Use register with inderect operand form ( "(%rdi)" )
Local Variables are often kept in registers rather than memory (registers accessed quicker)

Tools CS Assembly will be using over the next few weeks:
"Instruction set Architecture"
Three types:
--Computation, Accessing Memory, Changing control flow
--Names:
  mov instruction:
  Source can be immediate, register, or memory. Destination must be register or memory.
  Memory is exclusive (both can't be memory).
  %rax = 0xaaaaaaaaaaaaaaaa
  %rdi = 0xbbbbccccddddeeff
  movb,movw,movl,movq (8, 16, 32, 64)
  mov src, dest
  movz zero extend
  --movzbw (change the word to 0s and move in the byte (keep the rest of the register the same))
    movzbw %dil, %ax -->> %rax = aaaaaaaaaaaa00ff
    movzwl %di, %eax -->> %rax = 000000000000eeff (different because moving into 32bit register)
    movzbq == movzbl (movzbq doesnt exist because the quad is always zeroed when moving into 32bit register, BUT
                      it can exist if moving into a 64bit register)
  movs sign extend
  --movsbw (sign extend the word from the byte (extend from bit 8 through bit 16))
    movsbw %dil, %ax -->> %rax = aaaaaaaaaaaaffff (sign extend from bit 8 through bit 16)
    movsbq %dil, %rax -->> %rax = ffffffffffffffff (sign extend from bit 8 through bit 64)
    movswl %di, %eax -->> %rax = 00000000ffffeeff (sign extend from bit 16 through bit 32, but clear 64-32)
  "mov 1,2" "movq 1,2" (move 1 into 2) (q for move quad)

  "pushq S" (move the stack pointer to an empty spot and fill with S)
    R[%rsp] <- R[%rsp] - 8
    M[R[%rsp]] <- S
  "popq D" (Fill D with current latest stack pointer and move stack pointer back one slot (pop it))
    D <- M[R[%rsp]]
    R[%rsp] <- R[%rsp] + 8

  Arithmetic Assembly Operators
    Source can be immediate, register, or memory. Destination must be register or memory.
    Memory is exclusive (both can't be memory).
    "add S D" ==> D += S ("add S to D")
    "sub S D" ==> D -= S (careful! Not commutative, D = D - S "subtract S from D")
    "imul S D" ==> D *= S ("Multiply S to D")
    "inc D" ==> D++
    "dec D" ==> D--
    "neg D" ==> D *= -1
    "not D" ==> D = ~D
    "and S D" ==> D = D & S
    "or S D" ==> D = D | S
    "xor S D" ==> D = D ^ s
    Shift "k" can be an immediate or %cl
    "sal k D" ==> D << k (arithmetic shift) (SPECIAL: DOES THE SAME AS "shl"; fill with 0s)
    "shl k D" ==> D << k (logical shift) (fill with 0s)
    "sar k D" ==> D >> k (arithmetic shift) (fill with 1s)
    "slr k D" ==> D >> k (logical shift) (fill with 0s)

Acronyms Alain is saying:
--RISC: Reduced instruction set computer
--CISC: Complex instruction set computer
--ARM:
--MIPS:
--SPARK:
--SUN: (bought by ORACLE and developed JAVA)
--KFC:

Tools:
| (pipe, take output of first command and feed it into second command)
cc (c compiler)
"-fcf-protection-none" (helps with some sort of cybersecurity threat, to be talked about)
"-o name"
"mstore.c main.c" (two c files as input)
"-0g" (optimize my code please and thank you)
"-g" (add more debugging symbols to the program) (helps with gnu(gdb))

objdump (takes object/binary file and turns it back into assembly or understandable file)
"-d" disassemble (object file and give me something usable)
Does not try to give c code from object file
Returns readable file:
--location on left (in binary)
--machine instructions in middle
--keywords on right along with memory registers
"-f" (give summary):
--file format, architecture, some flags, start address
--Flags:
  DYNAMIC (some libraries linked, others not)
  D_PAGED (includes some debugging stuffs to make it more readable (identifiers))
"-c" (preprocess, compiler, assembler, but no linking)

"gdb progName"(gnu debugger)
"disassemble labelName" (gives addresses and instructions and registers)
"x/14xb labelName" (gives byte code at given location)
"break main" (add breakpoint(debugpoint) at main, if run program, stop at main)
"list" (give some information about sourcecode)
"where" (where are we running)
"next" || "n" (step forward (run whole next line)) (shows line to be executed)
"print d" (prints what is in variable d)
"help" (all of what you can do)
"step" (steps into line (if function call goes to top of function, etc))



Colors for Ross:
There are two warring chess factions, white and black. Each color is aligned with one side.
Red, Orange, Yellow are with White; Blue, Green, Purple are with Black
GRAY ARE THE MEDIATORS LMAO They wish for pure balance xD
The eternal conflict continues :) <3
