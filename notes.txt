---- ls -> list files
---- cd -> change directory
---- *command* & -> multithread (allow for use of console while in emacs)
---- ctrl-c -> close what working on
---- sftp *target@computername* -> "Secure file transfer protocol"
---- get *filename* -> take file from that computer and copy it to your computer
---- filename cheat: *partofFile*.pdf -> asterisks are wildcards and it gets any file that
     includes "partofFile" and ends in .pdf
---- cc -> call c compiler
---- gcc -o *name* *fileName* -> set a.out to be *name*
---- cc -lm -lX11 ->  "-lm" => link to math  "-lX11" => link to linux graphical library.
---- gcc -o *CompiledFileName* *FiletoCompile.c* -lm -lX11 -> use all stuff before and make
     it work for graphical things
---- gcc -O (capital O, makes the compiler optimize the code)
---- fg creates a whole bunch of files that are different steps of the compiler.
----"|" takes the output of the previous command and pipes it through another command
----"man" brings us the manual for a command
----"tar xfz *filename*.tgz" untar file (similar to a zip file, but different?)


C programming shit:
----"#define" makes constant GLOBAL variables for the program
----"#include" includes something, libraries are in <> and files are just names
----C passes everything EXCEPT ARRAYS by value (as copies)
    --can use pointers to pass things to pass actual things
      (arrays are always pointers so that makes sense)
----Strings: arrays of characters ended by "\0"
----"->" operator (instead of "class.method" (java) we use "class->method")
    --but we can still us ".variable" for public variables on non-pointers
----1 byte = 8 bits = 256 possible numbers
----Data types:
    --char => 1 byte
    --int => 4 bytes
    --long => 8 bytes
    --float => 4 bytes
    --double => 8 bytes
    --long double => 10 bytes
----Pointers:
  --char c; //declares char c
  --c = 65; //initializes char c to 65 ('a')
  --char *p; //declares pointer p to be pointer of type char
  --p = &c;  //p gets memory location of c
  --p = 0; //sets p to be the memory location 0
  --printf("%c\n", *p); //*p gets the value of the pointer (goes back and forth)
  --char **argv
    --argv points to pointers (an array of pointers to arrays)
    --printf line returns "Segmentation fault (core dumped)" because the OS got mad.
    --char *p is a pointer of type char in memory (declared by "*")
      --standardly takes up 8 bytes (64bit computing)
    --generate pointer of existing thing "&c"
    --can manufacture addresses
    --*p is the same as p[0] in this previous code (dereferencing a pointer gives you the value)
----Structs:
  --"struct cplx {double re; double im;}"
  --*in main* "struct cplx c1 = {1.0, 0.0}"
    --an inanimate object to store multiple variables (two doubles in this case)
    --can create with simple curly braces
----Bitwise operations:
    --FUTURE SKYE FIGURE THIS OUT
----Command line arguments
    --main can have arguments (as expected)
      --"int main(int argc, char **argv){}"
      --"argc" = integer, how many words on command line
      --"argv" = array of pointers to char arrays (array of strings)


CS 367 Graphics office hours: MWF 10:20-11:20 in Bodine 301


Functions and Parameter Passing in C: (2 September, 2021 Jeff)
--Functions pass copies of values inherently (as expected, methods cannot directly
  edit main program variables.
  --CAREFUL: Arrays break this. AND ONLY ARRAYS (because methods send memory location of
    initial part of array. In methods, always make copies of the arrays if you don't
    want to change them.
--Arrays don't have a .length, that is why G_polygon needs the number of items.


A look behind the curtain and pointers: (3 September, 2021 Alain)
--fg shows us the steps the compiler goes throug, then call "cc hello.c"
  --First the cpp makes "hello.i" (DONT KNOW WHAT THIS IS LMAO GOOD LUCK)
  --Then ccl (c compiler) creates "hello.s" in assembly language. (mostly assembly instructions)
    --First column are largely labels ("main:")
    --first column contains psuedoinstructions (".anything")
  --Then as makes "hello.o" which is a binary file (hard to show with less/emacs/regular editors
    --some code allows us to read it like assembly "objdump -d hello.o | less"
      --objdump is a tool in linux that lets us look at binary files (converts it to stuff we can read)
      --"-d" tells the program to find the instructions, and largely ignore the raw data
      --"|" takes the output of the previous command and pipes it through another command
      --objdump will show largely the same thing as "hello.s"
  --Then "ld" makes "hello" which is the executable file
    --"ld" includes the libraries? tf? I think they are inherent libraries that allow c to work
      --by default it includes the libraries (so i was right a line above this)
        (such as IO, or string, etc)
      --"-lm" tells the compiler to include math AS WELL AS "#include <math.h>"
        (we do it twice because C)
      
.xy file structure:
--Number of Verticies (int)
--double coordinates of verticies (double x double y)
--Number of polygons (int)
--Each polygon ("number of verticies" "verticy number" "verticy number") (all ints)
--Each polygon's color ("double r" "double g" "double b")



CS367 poly_perimetersS Lab:

--Count triangles twice, count non-triangles once
  --triangles are poitive slope then negative slope or negative slope then positive slope
    when vertex is in between xouters
    --perhaps worry about if a line is drawn twice on a polygon or not (two horizontal overlapping lines with
      vertex in the middle)



Bitwise and Signed/Unsigned shit:
--When evaluating, if you have one unsigned and one signed, they are evaluated as unsigned
--signed -1 = 1111 1111 1111 1111	(255U = -1)
         -2 = 1111 1111 1111 1110	(You subtract 1 from 255U to get -2)
	 -3 = 1111 1111 1111 1101  (You subtract 2 from 255U to get -3)
	 -4 = 1111 1111 1111 1100	(...)
--1 << 1  (Shift by one position)
  0001 << 1 = 0010 (multiply by magnitude of 2)
  0X0012 << 1 = 0X0024
  v << k ≡ v × 2^k
--1 >> 1 (Shift right by one position)
  0001 >> 1 = 0000 (shift bits)
  1111 1111 (-1)>> 1 == 1111 1111 (-1)
  1111 1110 (-2)>> 1 == 1111 1111 (-1)
  1111 1100 (-4)>> 2 == 1111 1111 (-1)
  0X0012 >> 1 = 0X0005
  v >> k = floor(v/2^k)
  Fills in all positions vacated with the most significant bit (for signed values) (arithmetic shift)
  Fills in all positions vacated with zeroes (for unsigned values) (logical shift)
  --Example:
    char c = -4;
    c >> 2 == -1; //true (any vacated bit positions have been backfilled with most significant bit)
    unsigned char cc = (unsigned char) -4; cc == 1111 1100 (252 unsigned (-4 signed))
    cc >> 2 == 63 //true (any vacated bit positions have been backfilled with zeroes)
--& operator
  1111 1011 & 1011 0011 == 1011 0011
--| operator
  1111 1011 | 1011 0011 == 1111 1011
--~ operator
  !1101 1111 == 0010 0000
--^ operator
  1111 1101 ^ 1001 1001 == 1001 1011


DeMorgan's Law (look up)
  

Floats in bits:

--What does 1011.101 represent?
  11.625 (11.5/8)
  (first four bits normal, next four 3 bits are 1/2 1/4 1/8)

--More generally our representation is b(subj) ... b(sub2) b(sub1) b(sub0) . b(sub-1) b(sub-2) ... b(sub-k)
  Result is sum from -k to j of b(subi)*2^i

  5 3/4 (5.75) to binary == 101.11
  2 7/8 (2.875) to binary == 10.111    (NOTICE: after the decimal point is the numerator in binary with leading zeroes
  1 7/16 (1.4375) to binary == 1.0111   if numerator is under 1/2)

--limitations to this form:
  --Cannot encode really small numbers or really big numbers

IEEE floating point form:
(-1)^s x M x 2^E
